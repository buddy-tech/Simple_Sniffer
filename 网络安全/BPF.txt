Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-12-03T20:06:28+08:00

====== BPF ======
Created Monday 03 December 2018

===== 什么是BPF =====
伯克利包过滤（Berkeley Packet Filter，BPF）语言。让你能够通过比较第2、3、4层协议中各个数据字段值的方法对流量进行过滤。BPF 中内置了一些“基元”来指代一些常用的协议字段。可以用“host”、"prot"之类的基元写出非常简洁的 BPF 过滤规则，也可以检测位于指定偏移量上的字段（甚至可以是一个位）的值。BPF 过滤器也可以由详尽的条件链和嵌套的逻辑“与”、“或”操作组成。

===== BPF基元 =====
现在，构造一个 BPF 过滤器的最简单的办法就是使用 BPF “基元”来指定协议、协议元素或者其他抓包规则。基元通常是由一个 id (名称或序号)再加上一个或多个限定符组成的。
* type 限定符：规定了 id 名或 id 序号指的是哪种类型的数据，可能的 type 有 host、net、prot 和 protrange
* dir 限定符：规定了流量是从 id 流进还是流出的（或两种兼有）。可能的 dir 有 src、dst、ser or dst、src and dst、addr1、addr2、addr3 和 addr4
* Proto 限定符：规定了所匹配的协议。可能的 proto 有：ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp 和 udp

假设我们现在希望仅仅获取 IP 地址为 192.168.0.1 的计算机与除 IP 地址 10.1.1.1 之外的其他所有计算机在 138、139 和 445 端口上发送的所有通信，下面这个 BPF 过滤规则就能完成上述任务：
'host 192.168.0.1 and not host 10.1.1.1 and (port 138 or port 139 or port 445)'

常用的BPF基元有:
'''
host id , dst host id , src host id
net id , dst net id , src net id
ether host id , ether dst host id , ether src host id
port id , dst port id , src port id
gateway id , ip proto id , ether proto id
tcp, udp, icmp, arp
vlan id
'''


===== 根据字节的值过滤数据包 =====
BPF语言也可以用来检查帧内任意一个单字节字段（或多字节字段）的值是不是规定值。下面是一些例子：

ip[8]<64

这个过滤规则规定要抓取的是：所有自ip头偏移8个字节的那个单字节字段的值小于64的IP包。被检查的这个字段表示的是“包的存活时间”或称“TTL”。大多数Windows系统中TTL的默认值是128，所以这个过滤规则将丢弃局域网中所有来自Windows系统的流量，只获取所有来自Linux系统的流量（因为在LInux系统中TTL的默认起始值是64）

ip[9]!=1

这一过滤规则规定要抓取的是所有IP头部偏移9个字节的那个单字节字段的值不等于“1”的帧。因为IP头部偏移9个字节的这个字段表示的是嵌入协议，如果等于“1”则表示“ICMP”协议，所以这个过滤规则将抓取除ICMP包之外的所有流量。这一表达式也等价于基元“not icmp”。

icmp[0] = 3 and icmp[1] = 0

这个语句规定要抓取的是：所有ICMP头部偏移0个字节的那个单字节字段等于3，且偏移1个字段的单字节字段等于0的ICMP数据包。换而言之，这一过滤规则将只抓取ICMPtype为3,code为0的“网络不可达”消息。

tcp[0:2] = 31337

这个语句检查了一个多字节字段，它检查的是：TCP头部偏移0个字节起的一个多字节字段（2个字节），该字段表示的是TCP源端口。所以这个表达式就等价于BPF基元“src prot 31337”

ip[12:4] = 0xC0A80101

我们看到的这是一个4字节的比较，它检查的是IP头部偏移12个字节起的4个字节里存放的数据——源IP地址。注意这个表达式里使用了十六进制表示法。转换成十进制数字，它就是192.168.1.1（0xC0=192,0xA8=168,0x01=1）。所以这一过滤规则将捕获所有源IP地址为192.168.1.1的流量。

===== 根据位（bit）的值过滤数据包 =====
BPF语言还提供了一种方法让我们能检查更小的字段或精度更高的偏移量。具体做法是：我们先引用相关的字节，或多个字节，然后再用“位掩码”逐位地把我们需要检查的位分离出来。

假设要过滤所有IP头部中可选字段被启用的包（就是IP头的长度大于20个字节的包）。IP头部的低半个字节表示的是IP头的长度，以“word”(字)为单位(一个word等于4个字节)。我们只需要找出这半个字节的值大于5（5word*4个字节/word=20个字节）的包就等于找出所有IP头部大于20个字节的包了。具体做法是用位掩码“00001111”（或者0x0F）创建一个BPF过滤规>>>则，通过逻辑“与”运算提取目标值。

ip[0] & 0x0F > 0x05 与之类似，如果我们要找出所有“不分片”标志位（位于IP头部偏移6个字节位置上的一位二进制位）被置1的IP包，我们亦可用二进制位掩码“01000000”（0x40）来表示我们只关心IP头部偏移6个字节位置上那个第二最高位的bit值是是不是1。

在构造位掩码是，如果对应的那一位是我们需要检查的，那就用1表示，否则就用0表示。

ip[6] & 0x40 != 0
